设计模式六大原则（2）：里氏替换原则
定义1：针对类型为T1的实例O1，都有类型T2的实例O2，在T1定义的所有程序P中，把所有O1对象都替换成
O2，P的行为没有发生变化，那么T2类型是 T1类型的子类行。
定义2：所有引用基类的地方都能透明的使用子类进行替换

问题由来：
类A有功能P，现在对功能P进行扩展，扩展后的功能为P2，其中功能P2，由原来的功能P，和新增的功能P1组成
新功能P2有A的子类B来完成，则B类在完成新功能P1的同时，可能会导致原有的功能P，发生故障

结果方式：
在使用类继承的时候，要遵循里式替换原则。类B继承类A的时候，除了新增方法完成新增的功能P1外，尽量不要重写
类A的方法，也尽量不要重载A类的方法

继承包含了这么一层含义：父类中凡是已经实现好的方法，实际上是在制定一系列的规则，虽然没有强制要求所有的
子类都要遵守这一规则，如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏，里式替换原则就是
表示这种意思。

    继承在给程序带来便利的同时也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了
程序之间的耦合性，当一个类被其它的类继承的时候，如果这个类被修改的时候，就必须考虑他的子类，父类修改后
他的子类可能也会发生故障。

举例说明继承可能会造成的故障

class A{
    public int func1(int a,int b){
        return a - b;
    }
}

public class Client{
    public static void main(String[] args){
        A a = new A();
        System.out.println("100-40="+a.func1(100, 40));
        System.out.println("100-20="+a.func1(100, 20));
    }
}
结果为：
100-40=60
100-20=80
后来我们增加了一个新的功能，计算两个数的 和 乘以 两个数的差
class B  extends A{
    public int fun1(int a,int b){
        return a + b;
    }
    public int fun2(int a,int b)
    {
        return fun1(a,b) * (a-b);
    }
}
public class Client{
	public static void main(String[] args){
		A  b = new B();
		System.out.println("100-40="+b.func1(100, 40));
		System.out.println("100-20="+b.func1(100, 20));

	}
}
执行结果为：
100-40=140
100-20=120


    我们发现原本执行正常的减法出现了异常，错误的原因就是B类重写了父类A的func1的方法，导致了
所有调用相减的功能都调用了类B重写的方法func1，造成了原本运行正常的结果出现了错误.
在本类中，引用基类A的功能换成子类 B 之后发生了异常。在开发过程中，我们往往通过重写父类的方法
来完成新的功能，这样写起来比较简单，但是整个继承体系的代码复用性比较差，尤其是频繁的使用多态的时候
出错的可能性就会变大。如果非要重写父类的方法时，我们通用的做法是：原来的父类和子类都继承一个更加
通俗的基类，原本的继承关系不用，采用依赖 聚合和组合来实现。

    里式替换简而言之：子类可以扩展父类的功能，但是不能改变父类的原有功能。有以下4个含义：
    1.子类可以实现父类的抽象方法，但是不能够覆盖父类的非抽象方法
    2.子类中可以添加自己的特有方法
    3.当子类重载父类的方法的时候，子类的入参要比父类更加宽松
    4.当子类的方法实现父类抽象的方法时(重写),方法的返回值要比父类更加严格
